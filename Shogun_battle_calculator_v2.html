<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Samurai Swords Battle Simulator</title>
    <style>
        .battle-container {
            display: flex;
            height: 100vh;
        }
        .army-setup-wrapper {
            display: flex;
            flex-direction: column;
            width: 800px;
        }
        .army-setup-row {
            display: flex;
            justify-content: space-between;
        }
        .controls-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .army-setup {
            display: inline-block;
            margin: 10px;
            padding: 10px;
            border: 2px solid;
            width: 350px;
        }
        .army-grid {
            display: grid;
            grid-template-rows: repeat(3, 1fr);
            gap: 10px;
        }
        .army-row {
            display: flex;
            gap: 10px;
            min-height: 100px;
            border: 1px dashed gray;
        }
        .unit {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            margin: 5px;
            border-radius: 5px;
            font-weight: bold;
        }
        .unit.selected-casualty {
            opacity: 0.5;
            text-decoration: line-through;
        }
        .red-army .unit {
            background-color: rgba(255, 0, 0, 0.3);
            border: 1px solid red;
        }
        .blue-army .unit {
            background-color: rgba(0, 0, 255, 0.3);
            border: 1px solid blue;
        }
        #battleLog {
            flex-grow: 1;
            margin: 10px;
            padding: 10px;
            border: 1px solid #ccc;
            height: calc(100vh - 20px);
            column-width: 300px;  /* Set a fixed column width */
            column-gap: 20px;
            column-fill: auto;    /* Fill columns vertically first */
            overflow: auto;        /* Keep scrolling just in case */
        }
        #battleLog h3 {
            column-span: all;
            text-align: center;
        }
        .battle-controls, .combat-controls {
            margin: 10px;
            padding: 10px;
        }
        .hit-highlight {
            background-color: rgba(255, 0, 0, 0.2);
        }
        .player-name {
            font-style: italic;
            margin-bottom: 10px;
            color: #666;
        }
        .controls-row {
            flex-direction: column;
            gap: 10px;
        }
        
        .battle-controls {
            display: flex;
            gap: 10px;
        }
    </style>
</head>
<body>
    <div class="battle-container">
        <div class="army-setup-wrapper">
            <div class="army-setup-row">
                <div id="redArmySetup" class="army-setup red-army">
                    <h2>Attacking Army</h2>
                    <div id="redArmyGrid" class="army-grid">
                        <div class="army-row" row="0"></div>
                        <div class="army-row" row="1"></div>
                        <div class="army-row" row="2"></div>
                    </div>
                    <div id="redUnitTypes" class="unit-types">
                        <button onclick="addUnit('red', 'Samurai')">Samurai</button>
                        <button onclick="addUnit('red', 'Archer')">Archer</button>
                        <button onclick="addUnit('red', 'Gunner')">Gunner</button>
                        <button onclick="addUnit('red', 'Ashigaru')">Ashigaru</button>
                        <button onclick="resetArmy('red')">Reset Army</button>
                    </div>
                </div>

                <div id="blueArmySetup" class="army-setup blue-army">
                    <h2>Defending Army</h2>
                    <div id="blueArmyGrid" class="army-grid">
                        <div class="army-row" row="0"></div>
                        <div class="army-row" row="1"></div>
                        <div class="army-row" row="2"></div>
                    </div>
                    <div id="blueUnitTypes" class="unit-types">
                        <button onclick="addUnit('blue', 'Samurai')">Samurai</button>
                        <button onclick="addUnit('blue', 'Archer')">Archer</button>
                        <button onclick="addUnit('blue', 'Gunner')">Gunner</button>
                        <button onclick="addUnit('blue', 'Ashigaru')">Ashigaru</button>
                        <button onclick="resetArmy('blue')">Reset Army</button>
                    </div>
                </div>
            </div>

            <div class="controls-row">
                <div class="battle-controls">
                    <button onclick="startBattle()">Start Battle</button>
                </div>

                <div class="combat-controls">
                    <div id="casualtyRemoval">
                        <h3 id="casualtyInstructions"></h3>
                        <button id="removeCasualtiesBtn" onclick="removeCasualties()" style="display:none;">Remove Casualties</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="battleLog">
            <h3>Battle Log</h3>
        </div>
    </div>

    <script>
        const UNIT_HIT_RULES = {
            'Daimyo': { hits: 6, dice: 12 },     // hits on 1-6 out of 12
            'Archer': { hits: 6, dice: 12 },    // hits on 1-6 out of 12
            'Samurai': { hits: 5, dice: 12 },    // hits on 1-5 out of 12
            'Gunner': { hits: 4, dice: 12 },    // hits on 1-4 out of 12
            'Ashigaru': { hits: 4, dice: 12 }    // hits on 1-4 out of 12
        };

        const UNIT_VALUES = {
            'Daimyo': 100,  // Effectively infinite as it must be last
            'Archer': 4,
            'Samurai': 3,
            'Gunner': 2,
            'Ashigaru': 1
        };        

        const VICTORY_MESSAGES = [
            "giggles with glee!",
            "dances on %loser%'s grave!",
            "meditates on success amongst the smoldering corpses of his enemy!",
            "bathes in their ancestors' pride!",
            "smiles smugly at %loser%!"
        ];
        
        const DEFEAT_MESSAGES = [
            "dies of shame.",
            "commits seppuku.",
            "has disgraced his ancestors.",
            "'s remaining units and provinces wish they had a more accomplished leader!",
            "skulks away to lick their wounds and vows revenge!"
        ];
        
        let currentBattleState = null;
        let currentPhase = null;
        let currentArmyRemoving = null;
        let combatRound = 0;

        // Initialize armies with Daimyo
        function initializeArmy(armyColor) {
            const grid = document.getElementById(`${armyColor}ArmyGrid`);
            const firstRow = grid.querySelector('.army-row[row="0"]');
            
            // Create Daimyo unit
            const daimyo = document.createElement('div');
            daimyo.className = 'unit';
            daimyo.textContent = 'D';
            daimyo.dataset.type = 'Daimyo';
            daimyo.onclick = () => removeUnit(daimyo);
            firstRow.appendChild(daimyo);
        }

        // Call initialization for both armies and banzai button
        initializeArmy('red');
        initializeArmy('blue');
        setupBattleControls();

        function setupBattleControls() {
            // Ensure battle controls container exists
            let battleControls = document.querySelector('.battle-controls');
            if (!battleControls) {
                battleControls = document.createElement('div');
                battleControls.className = 'battle-controls';
                document.querySelector('.controls-row').appendChild(battleControls);
            }
            
            // Get the existing Start Battle button
            const startButton = battleControls.querySelector('button');
            
            // Add Customize button
            if (!document.getElementById('customizeButton')) {
                const customizeButton = document.createElement('button');
                customizeButton.id = 'customizeButton';
                customizeButton.textContent = 'Customize';
                customizeButton.onclick = customizeArmies;
                // Insert after Start Battle button
                startButton.insertAdjacentElement('afterend', customizeButton);
            }
            
            // Add Banzai button
            if (!document.getElementById('banzaiButton')) {
                const banzaiButton = document.createElement('button');
                banzaiButton.id = 'banzaiButton';
                banzaiButton.textContent = 'Banzai!';
                banzaiButton.onclick = startBanzaiBattle;
                // Insert after Customize button
                document.getElementById('customizeButton').insertAdjacentElement('afterend', banzaiButton);
            }
        }

        function customizeArmies() {
            // Get army names
            const redArmyName = prompt('Enter a name for the Red Army:', 'Red Army');
            const blueArmyName = prompt('Enter a name for the Blue Army:', 'Blue Army');
            
            // Update army titles if names were provided
            if (redArmyName) {
                document.querySelector('#redArmySetup h2').textContent = redArmyName;
            }
            if (blueArmyName) {
                document.querySelector('#blueArmySetup h2').textContent = blueArmyName;
            }
            
            // Ask about player names
            const addPlayerNames = confirm('Would you like to add player names?');
            if (addPlayerNames) {
                const redPlayerName = prompt('Enter player name for ' + (redArmyName || 'Red Army') + ':', '');
                const bluePlayerName = prompt('Enter player name for ' + (blueArmyName || 'Blue Army') + ':', '');
                
                // Add player names under army titles if provided
                if (redPlayerName) {
                    let redPlayerDiv = document.querySelector('#redArmySetup .player-name');
                    if (!redPlayerDiv) {
                        redPlayerDiv = document.createElement('div');
                        redPlayerDiv.className = 'player-name';
                        document.querySelector('#redArmySetup h2').insertAdjacentElement('afterend', redPlayerDiv);
                    }
                    redPlayerDiv.textContent = `Commander: ${redPlayerName}`;
                }
                
                if (bluePlayerName) {
                    let bluePlayerDiv = document.querySelector('#blueArmySetup .player-name');
                    if (!bluePlayerDiv) {
                        bluePlayerDiv = document.createElement('div');
                        bluePlayerDiv.className = 'player-name';
                        document.querySelector('#blueArmySetup h2').insertAdjacentElement('afterend', bluePlayerDiv);
                    }
                    bluePlayerDiv.textContent = `Commander: ${bluePlayerName}`;
                }
            }
        }

        // Function to get army name
        function getArmyName(color) {
            const armyTitle = document.querySelector(`#${color}ArmySetup h2`).textContent;
            return armyTitle || `${color.toUpperCase()} Army`;
        }
        
        // Function to get player name
        function getPlayerName(color) {
            const playerDiv = document.querySelector(`#${color}ArmySetup .player-name`);
            return playerDiv ? playerDiv.textContent.replace('Commander: ', '') : null;
        }
        
        // Function to get random message
        function getRandomMessage(array) {
            return array[Math.floor(Math.random() * array.length)];
        }
        
        function findAvailableRow(armyColor, unitType) {
            const grid = document.getElementById(`${armyColor}ArmyGrid`);
            const rows = grid.querySelectorAll('.army-row');
            
            // First row: Daimyo (pre-populated), Archers, and Samurai
            if (['Archer', 'Samurai'].includes(unitType)) {
                const firstRow = rows[0];
                if (firstRow.children.length < 5) {
                    return firstRow;
                }
            }
        
            // Rows 2 and 3: Gunner first, then Ashigaru
            if (['Gunner', 'Ashigaru'].includes(unitType)) {
                const secondRow = rows[1];
                const thirdRow = rows[2];
                
                // Prioritize Gunner in the second row first
                if (unitType === 'Gunner' && secondRow.children.length < 5) {
                    return secondRow;
                }
                
                // If no more space for Gunner in second row, try third row
                if (unitType === 'Gunner' && thirdRow.children.length < 5) {
                    return thirdRow;
                }
                
                // For Ashigaru, first try second row
                if (unitType === 'Ashigaru') {
                    // Check if there's space in second row
                    if (secondRow.children.length < 5) {
                        return secondRow;
                    }
                    
                    // If second row is full, try third row
                    if (thirdRow.children.length < 5) {
                        return thirdRow;
                    }
                }
            }
        
            return null;
        }

        function sortRowUnits(row) {
            const priority = {
                'Daimyo': 1,  // Always first in first row
                'Archer': 2,
                'Samurai': 3,
                'Gunner': 1, // First in subsequent rows
                'Ashigaru': 2
            };
        
            const units = Array.from(row.children);
            
            // Sort units based on priority
            const sortedUnits = units.sort((a, b) => {
                const priorityA = priority[a.dataset.type] || 99;
                const priorityB = priority[b.dataset.type] || 99;
                return priorityA - priorityB;
            });
        
            // Clear and re-add sorted units
            row.innerHTML = '';
            sortedUnits.forEach(unit => row.appendChild(unit));
        }

        function addUnit(armyColor, unitType) {
            const totalUnits = document.querySelectorAll(`.${armyColor}-army .unit`).length;
            if (totalUnits >= 15) {
                alert('Army is at maximum capacity (15 units)');
                return;
            }
        
            const row = findAvailableRow(armyColor, unitType);
            if (row) {
                const unit = document.createElement('div');
                unit.className = 'unit';
                
                // Set unit text based on type
                switch(unitType) {
                    case 'Daimyo': unit.textContent = 'D'; break;
                    case 'Archer': unit.textContent = 'A'; break;
                    case 'Samurai': unit.textContent = 'S'; break;
                    case 'Gunner': unit.textContent = 'g'; break;
                    case 'Ashigaru': unit.textContent = 'a'; break;
                }
                
                unit.dataset.type = unitType;
                unit.onclick = () => removeUnit(unit);
                row.appendChild(unit);
        
                // Sort units in the row
                sortRowUnits(row);
            } else {
                alert('No space available for this unit type in the army');
            }
        }

        function removeUnit(unitElement) {
            // If currently selecting casualties, handle selection
            if (currentArmyRemoving) {
                // Check if the unit belongs to the correct army
                const unitArmy = unitElement.closest('.army-setup').id.startsWith('red') ? 'red' : 'blue';
                if (unitArmy === currentArmyRemoving) {
                    // Get count of non-Daimyo units available
                    const armyGrid = document.getElementById(`${unitArmy}ArmyGrid`);
                    const nonDaimyoUnits = Array.from(armyGrid.querySelectorAll('.unit')).filter(unit => 
                        unit.dataset.type !== 'Daimyo' && !unit.classList.contains('selected-casualty')
                    ).length;
        
                    // Only allow Daimyo selection if no other units are available
                    if (unitElement.dataset.type === 'Daimyo' && nonDaimyoUnits > 0) {
                        return; // Prevent Daimyo selection if other units exist
                    }
        
                    // Toggle the selected-casualty class
                    unitElement.classList.toggle('selected-casualty');
                }
            } else {
                // During army setup, prevent Daimyo removal
                if (unitElement.dataset.type === 'Daimyo') {
                    return; // Prevent Daimyo removal
                }
                // Normal unit removal during army setup
                unitElement.remove();
            }
        }

        function resetArmy(armyColor) {
            const grid = document.getElementById(`${armyColor}ArmyGrid`);
            const rows = grid.querySelectorAll('.army-row');
            rows.forEach(row => {
                row.innerHTML = '';
            });
            initializeArmy(armyColor);
        }

        function rollDice(maxHits, totalDice) {
            let hits = 0;
            for (let i = 0; i < totalDice; i++) {
                if (Math.floor(Math.random() * 12) + 1 <= maxHits) {
                    hits++;
                }
            }
            return hits;
        }
   
        function startBattle() {
            const redArmy = document.querySelectorAll('#redArmyGrid .unit');
            const blueArmy = document.querySelectorAll('#blueArmyGrid .unit');
            
            if (redArmy.length === 0 || blueArmy.length === 0) {
                alert('Both armies must have units to start battle!');
                return;
            }
        
            // Hide customize button along with other controls
            const customizeButton = document.getElementById('customizeButton');
            const startButton = document.querySelector('.battle-controls button');
            const banzaiButton = document.getElementById('banzaiButton');
            
            if (customizeButton) customizeButton.style.display = 'none';
            if (startButton) startButton.style.display = 'none';
            if (banzaiButton) banzaiButton.style.display = 'none';
            
            // Hide all unit control buttons
            document.querySelectorAll('#redUnitTypes button, #blueUnitTypes button').forEach(button => {
                button.style.display = 'none';
            });
            
            // Increment combat round
            combatRound++;
            
            const log = document.getElementById('battleLog');
            log.innerHTML += `<br><b>Combat Round ${combatRound}</b><br>`;
            
            // Start with Missile Phase
            currentPhase = 'Missile';
            currentBattleState = simulateMissilePhase(redArmy, blueArmy);
            
            // Always prepare blue army casualties first
            if (currentBattleState.blueCasualties > 0) {
                prepareCasualtyRemoval('blue', currentBattleState.blueCasualties);
            } else {
                // If no blue casualties, immediately proceed to red casualties
                prepareCasualtyRemoval('red', currentBattleState.redCasualties);
            }
        }

        function processPhaseCasualties(battleState) {
            // If both armies have casualties
            if (battleState.blueCasualties > 0 && battleState.redCasualties > 0) {
                // Start with blue army casualties
                prepareCasualtyRemoval('blue', battleState.blueCasualties);
            } 
            // If only blue army has casualties
            else if (battleState.blueCasualties > 0) {
                prepareCasualtyRemoval('blue', battleState.blueCasualties);
            } 
            // If only red army has casualties
            else if (battleState.redCasualties > 0) {
                prepareCasualtyRemoval('red', battleState.redCasualties);
            } 
            // If no casualties, proceed to next phase
            else {
                proceedToNextPhase();
            }
        }

        function proceedToNextPhase() {
            // Switch phases
            if (currentPhase === 'Missile') {
                currentPhase = 'Melee';
                currentBattleState = simulateMeleePhase(
                    document.querySelectorAll('#redArmyGrid .unit'),
                    document.querySelectorAll('#blueArmyGrid .unit')
                );
                processPhaseCasualties(currentBattleState);
            } else {
                // End of combat round
                endCombatRound();
            }
        }
        
        function proceedToRedCasualties() {
            // If there are red army casualties from missile phase
            if (currentBattleState.redCasualties > 0) {
                prepareCasualtyRemoval('red', currentBattleState.redCasualties);
            } else {
                // If no red casualties, proceed to melee phase
                proceedToMeleePhase();
            }
        }
        
        function proceedToRedMeleeCasualties() {
            // If there are red army casualties from melee phase
            if (currentBattleState.redCasualties > 0) {
                prepareCasualtyRemoval('red', currentBattleState.redCasualties);
            } else {
                // If no casualties for either army, end the combat round
                endCombatRound();
            }
        }
        
        function proceedToMeleePhase() {
            // Start Melee Phase
            currentPhase = 'Melee';
            currentBattleState = simulateMeleePhase(
                document.querySelectorAll('#redArmyGrid .unit'),
                document.querySelectorAll('#blueArmyGrid .unit')
            );
            
            // Always prepare blue army casualties first
            if (currentBattleState.blueCasualties > 0) {
                prepareCasualtyRemoval('blue', currentBattleState.blueCasualties);
            } else {
                // If no blue casualties, immediately proceed to red casualties
                prepareCasualtyRemoval('red', currentBattleState.redCasualties);
            }
        }
      
        function endCombatRound() {
            const confirmContinue = confirm('Do you want to continue the battle?');
            if (confirmContinue) {
                startBattle(); // Starts a new round
            } else {
                const log = document.getElementById('battleLog');
                log.innerHTML += '<br>Battle has been concluded.<br>';
                log.innerHTML += '<br><i>(Reload the page to start a new battle - press F5)</i><br>';
                
                // Add export log button only at the end of the battle
                if (!document.getElementById('exportLogButton')) {
                    const exportButton = document.createElement('button');
                    exportButton.id = 'exportLogButton';
                    exportButton.textContent = 'Export Battle Log';
                    exportButton.onclick = exportBattleLog;
                    document.querySelector('.battle-controls').appendChild(exportButton);
                }
                
                currentBattleState = null;
                currentPhase = null;
            }
        }
        
        function highlightLog(logText) {
            // Create a temporary div to handle the highlighting
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = logText;
            
            // Find and wrap "hit" with a span for highlighting
            const textNodes = [];
            
            // Recursive function to find text nodes
            function getTextNodes(node) {
                if (node.nodeType === Node.TEXT_NODE) {
                    textNodes.push(node);
                } else {
                    for (let child of node.childNodes) {
                        getTextNodes(child);
                    }
                }
            }
            
            getTextNodes(tempDiv);
            
            // Replace "hit" in text nodes
            textNodes.forEach(textNode => {
                const text = textNode.textContent;
                if (text.includes('hit')) {
                    const replacedText = text.replace(/hit/g, '<span class="hit-highlight">hit</span>');
                    const tempSpan = document.createElement('span');
                    tempSpan.innerHTML = replacedText;
                    textNode.parentNode.replaceChild(tempSpan, textNode);
                }
            });
            
            return tempDiv.innerHTML;
        }
        
        function simulateMissilePhase(redArmy, blueArmy) {
            const log = document.getElementById('battleLog');
            const redArmyName = getArmyName('red');
            const blueArmyName = getArmyName('blue');
            log.innerHTML += '<br><u>Missile Phase</u>:<br>';
        
            const redMissileUnits = {
                Archer: Array.from(redArmy).filter(u => u.dataset.type === 'Archer'),
                Gunner: Array.from(redArmy).filter(u => u.dataset.type === 'Gunner')
            };
        
            const blueMissileUnits = {
                Archer: Array.from(blueArmy).filter(u => u.dataset.type === 'Archer'),
                Gunner: Array.from(blueArmy).filter(u => u.dataset.type === 'Gunner')
            };
        
            // Function to process unit rolls and create log
            const processUnitRolls = (army, units) => {
                let missileLog = '';
                let hits = 0;
        
                Object.entries(units).forEach(([type, unitList]) => {
                    if (unitList.length > 0) {
                        const typeRolls = unitList.map(unit => {
                            const rules = UNIT_HIT_RULES[type];
                            const roll = Math.floor(Math.random() * 12) + 1;
                            const hit = roll <= rules.hits;
                            return hit ? `hit (${roll})` : `miss (${roll})`;
                        });
                        
                        const armyName = army === 'Red' ? redArmyName : blueArmyName;
                        missileLog += `${armyName} ${type}s: ${typeRolls.join(', ')}<br>`;
                        const typeHits = typeRolls.filter(roll => roll.startsWith('hit')).length;
                        hits += typeHits;
                    }
                });
        
                missileLog += `Total ${army === 'Red' ? redArmyName : blueArmyName} Missile Hits: ${hits}<br>`;
                return { log: missileLog, hits };
            };
        
            // Process missile phase for both armies
            const redResults = processUnitRolls('Red', redMissileUnits);
            const blueResults = processUnitRolls('Blue', blueMissileUnits);
        
            // Update battle log with highlighting
            document.getElementById('battleLog').innerHTML += 
                highlightLog(redResults.log + '<br>' + blueResults.log);
        
            return {
                redArmy,
                blueArmy,
                blueCasualties: redResults.hits,
                redCasualties: blueResults.hits
            };
        }

        function prepareCasualtyRemoval(armyColor, casualties) {
            // Check if battle has already ended
            if (!currentBattleState) {
                return;
            }
        
            const instructions = document.getElementById('casualtyInstructions');
            const removeButton = document.getElementById('removeCasualtiesBtn');
            const log = document.getElementById('battleLog');
            
            // Reset any previous selections
            const previousSelected = document.querySelectorAll('.selected-casualty');
            previousSelected.forEach(el => el.classList.remove('selected-casualty'));
        
            // Get remaining units for both armies
            const redArmyGrid = document.getElementById('redArmyGrid');
            const blueArmyGrid = document.getElementById('blueArmyGrid');
            const redUnits = redArmyGrid.querySelectorAll('.unit');
            const blueUnits = blueArmyGrid.querySelectorAll('.unit');
        
            // Check if current casualties would destroy the current army
            const currentArmyGrid = document.getElementById(`${armyColor}ArmyGrid`);
            const remainingUnits = currentArmyGrid.querySelectorAll('.unit');
            const nonDaimyoUnits = Array.from(remainingUnits).filter(unit => unit.dataset.type !== 'Daimyo').length;
        
            // If casualties would destroy the current army...
            if (casualties >= remainingUnits.length) {
                // Check if both armies would be destroyed in this phase
                const otherArmy = armyColor === 'blue' ? 'red' : 'blue';
                const otherArmyUnits = document.getElementById(`${otherArmy}ArmyGrid`).querySelectorAll('.unit');
                const otherArmyCasualties = currentBattleState[`${otherArmy}Casualties`];
        
                if (otherArmyCasualties >= otherArmyUnits.length) {
                    // Both armies are destroyed
                    log.innerHTML += '<br>The armies have annihilated each other!!<br>';
                    redArmyGrid.innerHTML = '';
                    blueArmyGrid.innerHTML = '';
                } else {
                    // Only current army is destroyed
                    log.innerHTML += `<br>${armyColor.toUpperCase()} Army is completely destroyed!<br>`;
                    currentArmyGrid.innerHTML = '';
                    
                    // Determine the winner
                    const victorArmy = armyColor === 'blue' ? 'Red' : 'Blue';
                    log.innerHTML += `${victorArmy} Army is victorious!<br>`;
                }
        
                log.innerHTML += '<br><i>(Reload the page to start a new battle - press F5)</i><br>';
                
                // Make sure battle controls container exists and is visible
                let battleControls = document.querySelector('.battle-controls');
                if (!battleControls) {
                    battleControls = document.createElement('div');
                    battleControls.className = 'battle-controls';
                    document.querySelector('.controls-row').appendChild(battleControls);
                }
                
                // Add export log button if it doesn't exist
                if (!document.getElementById('exportLogButton')) {
                    const exportButton = document.createElement('button');
                    exportButton.id = 'exportLogButton';
                    exportButton.textContent = 'Export Battle Log';
                    exportButton.onclick = exportBattleLog;
                    battleControls.appendChild(exportButton);
                }
                
                currentBattleState = null;
                currentPhase = null;
                return;
            }
        
            // Check if casualties are valid
            if (casualties === 0) {
                // Proceed to next phase based on current phase
                if (currentPhase === 'Missile') {
                    if (armyColor === 'blue') {
                        proceedToRedCasualties();
                    } else {
                        proceedToMeleePhase();
                    }
                } else if (currentPhase === 'Melee') {
                    if (armyColor === 'blue') {
                        proceedToRedMeleeCasualties();
                    } else {
                        endCombatRound();
                    }
                }
                return;
            }
        
            currentArmyRemoving = armyColor;
        
            let instructionText = `<div style="font-size: 1.2em; margin-bottom: 8px;"><b>${currentPhase} Phase Casualties</b></div>`;
            instructionText += `${armyColor.toUpperCase()} Army: Select ${casualties} casualties to remove`;
            if (nonDaimyoUnits > 0) {
                instructionText += " (Daimyo must be the last unit remaining)";
            }
            instructions.innerHTML = instructionText;
            removeButton.style.display = 'block';
        }

        function removeCasualties() {
            const selectedCasualties = document.querySelectorAll('.selected-casualty');
            const expectedCasualties = currentBattleState[`${currentArmyRemoving}Casualties`];
        
            // Validate correct number of casualties selected
            if (selectedCasualties.length !== expectedCasualties) {
                alert(`Please select exactly ${expectedCasualties} casualties`);
                return;
            }
        
            // Remove selected casualties
            selectedCasualties.forEach(casualty => casualty.remove());
        
            // Hide remove button
            document.getElementById('removeCasualtiesBtn').style.display = 'none';
        
            // Determine next steps based on current phase and army removing
            if (currentPhase === 'Missile') {
                if (currentArmyRemoving === 'blue') {
                    // After blue casualties, always process red casualties
                    prepareCasualtyRemoval('red', currentBattleState.redCasualties);
                } else if (currentArmyRemoving === 'red') {
                    // After red casualties in missile phase, move to melee phase
                    proceedToMeleePhase();
                }
            } else if (currentPhase === 'Melee') {
                if (currentArmyRemoving === 'blue') {
                    // After blue casualties, process red casualties
                    prepareCasualtyRemoval('red', currentBattleState.redCasualties);
                } else if (currentArmyRemoving === 'red') {
                    // After red casualties in melee phase, end the round
                    endCombatRound();
                }
            }
        }

        function handleNextPhase() {
            // If just finished missile phase, start melee phase
            if (currentPhase === 'Missile') {
                currentPhase = 'Melee';
                currentBattleState = simulateMeleePhase(
                    document.querySelectorAll('#redArmyGrid .unit'),
                    document.querySelectorAll('#blueArmyGrid .unit')
                );
                
                // Prepare red army casualties
                if (currentBattleState.redCasualties > 0) {
                    prepareCasualtyRemoval('red', currentBattleState.redCasualties);
                } else {
                    // If no red casualties, confirm to continue
                    const confirmContinue = confirm('Do you want to continue the battle?');
                    if (confirmContinue) {
                        startBattle(); // Starts a new round
                    } else {
                        document.getElementById('battleLog').innerHTML += 
                            '<br>Battle has been concluded.';
                        currentBattleState = null;
                        currentPhase = null;
                    }
                }
            } 
            // If just finished red casualties, confirm to continue
            else {
                const confirmContinue = confirm('Do you want to continue the battle?');
                if (confirmContinue) {
                    startBattle(); // Starts a new round
                } else {
                    document.getElementById('battleLog').innerHTML += 
                        '<br>Battle has been concluded.';
                    currentBattleState = null;
                    currentPhase = null;
                }
            }
        }
        
        function simulateMeleePhase(redArmy, blueArmy) {
            const log = document.getElementById('battleLog');
            const redArmyName = getArmyName('red');
            const blueArmyName = getArmyName('blue');
            log.innerHTML += '<br><u>Melee Phase</u>:<br>';
        
            const redMeleeUnits = {
                Daimyo: Array.from(redArmy).filter(u => u.dataset.type === 'Daimyo'),
                Samurai: Array.from(redArmy).filter(u => u.dataset.type === 'Samurai'),
                Ashigaru: Array.from(redArmy).filter(u => u.dataset.type === 'Ashigaru')
            };
        
            const blueMeleeUnits = {
                Daimyo: Array.from(blueArmy).filter(u => u.dataset.type === 'Daimyo'),
                Samurai: Array.from(blueArmy).filter(u => u.dataset.type === 'Samurai'),
                Ashigaru: Array.from(blueArmy).filter(u => u.dataset.type === 'Ashigaru')
            };
        
            // Function to process unit rolls and create log
            const processUnitRolls = (army, units) => {
                let meleeLog = '';
                let hits = 0;
        
                Object.entries(units).forEach(([type, unitList]) => {
                    if (unitList.length > 0) {
                        const typeRolls = unitList.map(unit => {
                            const rules = UNIT_HIT_RULES[type];
                            const roll = Math.floor(Math.random() * 12) + 1;
                            const hit = roll <= rules.hits;
                            return hit ? `hit (${roll})` : `miss (${roll})`;
                        });
                        
                        const armyName = army === 'Red' ? redArmyName : blueArmyName;
                        meleeLog += `${armyName} ${type}s: ${typeRolls.join(', ')}<br>`;
                        const typeHits = typeRolls.filter(roll => roll.startsWith('hit')).length;
                        hits += typeHits;
                    }
                });
        
                meleeLog += `Total ${army === 'Red' ? redArmyName : blueArmyName} Melee Hits: ${hits}<br>`;
                return { log: meleeLog, hits };
            };
        
            // Process melee phase for both armies
            const redResults = processUnitRolls('Red', redMeleeUnits);
            const blueResults = processUnitRolls('Blue', blueMeleeUnits);
                
            // Update battle log with highlighting
            document.getElementById('battleLog').innerHTML += 
                highlightLog(redResults.log + '<br>' + blueResults.log);
         
            return {
                redArmy,
                blueArmy,
                blueCasualties: redResults.hits,
                redCasualties: blueResults.hits
            };
        }

        function exportBattleLog() {
            const log = document.getElementById('battleLog').innerText;
            const blob = new Blob([log], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'battle_log.txt';
            a.click();
            window.URL.revokeObjectURL(url);
        }

        // Banzai battle resolution section
        function startBanzaiBattle() {
            const redArmy = document.querySelectorAll('#redArmyGrid .unit');
            const blueArmy = document.querySelectorAll('#blueArmyGrid .unit');
            
            if (redArmy.length === 0 || blueArmy.length === 0) {
                alert('Both armies must have units to start battle!');
                return;
            }
        
            // Disable all control buttons
            document.querySelector('.battle-controls').style.display = 'none';
            document.querySelectorAll('#redUnitTypes button, #blueUnitTypes button').forEach(button => {
                button.style.display = 'none';
            });
        
            runBanzaiBattleRound();
        }
        
        function runBanzaiBattleRound() {
            const redArmy = document.querySelectorAll('#redArmyGrid .unit');
            const blueArmy = document.querySelectorAll('#blueArmyGrid .unit');
            
            if (redArmy.length === 0 || blueArmy.length === 0) {
                endBanzaiBattle();
                return;
            }
        
            // Increment and log combat round
            combatRound++;
            const log = document.getElementById('battleLog');
            log.innerHTML += `<br><b>Combat Round ${combatRound}</b><br>`;
        
            // Run Missile Phase
            const missileState = simulateMissilePhase(redArmy, blueArmy);
            
            // Process missile casualties
            if (missileState.blueCasualties > 0) {
                const blueCasualties = selectOptimalCasualties('blue', missileState.blueCasualties, 'Melee');
                removeBanzaiCasualties('blue', blueCasualties);
            }
            
            if (missileState.redCasualties > 0) {
                const redCasualties = selectOptimalCasualties('red', missileState.redCasualties, 'Melee');
                removeBanzaiCasualties('red', redCasualties);
            }
        
            // Check if battle should continue
            if (document.querySelectorAll('#redArmyGrid .unit').length === 0 || 
                document.querySelectorAll('#blueArmyGrid .unit').length === 0) {
                endBanzaiBattle();
                return;
            }
        
            // Run Melee Phase
            const meleeState = simulateMeleePhase(
                document.querySelectorAll('#redArmyGrid .unit'),
                document.querySelectorAll('#blueArmyGrid .unit')
            );
        
            // Process melee casualties
            if (meleeState.blueCasualties > 0) {
                const blueCasualties = selectOptimalCasualties('blue', meleeState.blueCasualties, 'Missile');
                removeBanzaiCasualties('blue', blueCasualties);
            }
            
            if (meleeState.redCasualties > 0) {
                const redCasualties = selectOptimalCasualties('red', meleeState.redCasualties, 'Missile');
                removeBanzaiCasualties('red', redCasualties);
            }
        
            // Check if battle should continue
            if (document.querySelectorAll('#redArmyGrid .unit').length === 0 || 
                document.querySelectorAll('#blueArmyGrid .unit').length === 0) {
                endBanzaiBattle();
                return;
            }
        
            // Continue to next round
            setTimeout(runBanzaiBattleRound, 1000); // Add delay between rounds
        }
        
        function selectOptimalCasualties(armyColor, casualtyCount, nextPhase) {
            const armyGrid = document.getElementById(`${armyColor}ArmyGrid`);
            const units = Array.from(armyGrid.querySelectorAll('.unit'));
            const casualties = [];
            
            // Never select Daimyo unless it's the last unit
            const nonDaimyoUnits = units.filter(unit => unit.dataset.type !== 'Daimyo');
            if (nonDaimyoUnits.length === 0 && casualtyCount > 0) {
                return [units[0]]; // Return Daimyo if it's the last unit
            }
        
            // Create lists of units by type
            const unitsByType = {
                'Archer': units.filter(u => u.dataset.type === 'Archer'),
                'Samurai': units.filter(u => u.dataset.type === 'Samurai'),
                'Gunner': units.filter(u => u.dataset.type === 'Gunner'),
                'Ashigaru': units.filter(u => u.dataset.type === 'Ashigaru')
            };
        
            // Define unit selection priority based on next phase
            const priorityList = nextPhase === 'Missile' ? 
                ['Gunner', 'Ashigaru', 'Archer', 'Samurai'] : // Preserve missile units
                ['Ashigaru', 'Gunner', 'Samurai', 'Archer'];  // Preserve melee units
        
            // Select casualties based on priority
            while (casualties.length < casualtyCount && nonDaimyoUnits.length > casualties.length) {
                for (const unitType of priorityList) {
                    if (casualties.length >= casualtyCount) break;
                    
                    const availableUnits = unitsByType[unitType].filter(
                        unit => !casualties.includes(unit)
                    );
                    
                    if (availableUnits.length > 0) {
                        casualties.push(availableUnits[0]);
                    }
                }
            }
        
            return casualties;
        }
        
        function removeBanzaiCasualties(armyColor, casualties) {
            const log = document.getElementById('battleLog');
            log.innerHTML += `<br>${armyColor.toUpperCase()} Army removes: ${
                casualties.map(unit => unit.dataset.type).join(', ')
            }<br>`;
            
            casualties.forEach(unit => unit.remove());
        }
        
        function endBanzaiBattle() {
            const log = document.getElementById('battleLog');
            const redArmy = document.querySelectorAll('#redArmyGrid .unit');
            const blueArmy = document.querySelectorAll('#blueArmyGrid .unit');
        
            if (redArmy.length === 0 && blueArmy.length === 0) {
                log.innerHTML += '<br>The armies have annihilated each other!!<br>';
            } else if (redArmy.length === 0) {
                log.innerHTML += '<br>RED Army is completely destroyed!<br>BLUE Army is victorious!<br>';
            } else if (blueArmy.length === 0) {
                log.innerHTML += '<br>BLUE Army is completely destroyed!<br>RED Army is victorious!<br>';
            }
        
            log.innerHTML += '<br><i>(Reload the page to start a new battle - press F5)</i><br>';
            
            // Show battle controls container if hidden
            const battleControls = document.querySelector('.battle-controls');
            battleControls.style.display = 'block';
            
            // Add export log button if it doesn't exist
            if (!document.getElementById('exportLogButton')) {
                const exportButton = document.createElement('button');
                exportButton.id = 'exportLogButton';
                exportButton.textContent = 'Export Battle Log';
                exportButton.onclick = exportBattleLog;
                battleControls.appendChild(exportButton);
                
                // Make sure only the export button is visible
                battleControls.querySelectorAll('button').forEach(button => {
                    if (button.id !== 'exportLogButton') {
                        button.style.display = 'none';
                    }
                });
            }
        }

        // Update the endCombatRound and endBanzaiBattle functions to use custom names and add player messages
        function addBattleEndMessages(log, redDestroyed, blueDestroyed) {
            const redArmyName = getArmyName('red');
            const blueArmyName = getArmyName('blue');
            const redPlayer = getPlayerName('red');
            const bluePlayer = getPlayerName('blue');
        
            if (redDestroyed && blueDestroyed) {
                log.innerHTML += `<br>The ${redArmyName} and ${blueArmyName} have annihilated each other!!<br>`;
                if (redPlayer && bluePlayer) {
                    log.innerHTML += `<br>Both ${redPlayer} and ${bluePlayer} ${getRandomMessage(DEFEAT_MESSAGES)}<br>`;
                }
            } else if (redDestroyed) {
                log.innerHTML += `<br>${redArmyName} is completely destroyed!<br>${blueArmyName} is victorious!<br>`;
                if (redPlayer && bluePlayer) {
                    let victoryMsg = getRandomMessage(VICTORY_MESSAGES).replace('%loser%', redPlayer);
                    let defeatMsg = getRandomMessage(DEFEAT_MESSAGES);
                    log.innerHTML += `<br>${bluePlayer} ${victoryMsg}<br>${redPlayer} ${defeatMsg}<br>`;
                }
            } else if (blueDestroyed) {
                log.innerHTML += `<br>${blueArmyName} is completely destroyed!<br>${redArmyName} is victorious!<br>`;
                if (redPlayer && bluePlayer) {
                    let victoryMsg = getRandomMessage(VICTORY_MESSAGES).replace('%loser%', bluePlayer);
                    let defeatMsg = getRandomMessage(DEFEAT_MESSAGES);
                    log.innerHTML += `<br>${redPlayer} ${victoryMsg}<br>${bluePlayer} ${defeatMsg}<br>`;
                }
            }
        }
        
    </script>
</body>
</html>
