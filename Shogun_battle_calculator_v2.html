<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Samurai Swords Battle Simulator</title>
    <style>
        .battle-container {
            display: flex;
            height: 100vh;
        }
        .army-setup-wrapper {
            display: flex;
            flex-direction: column;
            width: 800px;
        }
        .army-setup-row {
            display: flex;
            justify-content: space-between;
        }
        .controls-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .army-setup {
            display: inline-block;
            margin: 10px;
            padding: 10px;
            border: 2px solid;
            width: 350px;
        }
        .army-grid {
            display: grid;
            grid-template-rows: repeat(3, 1fr);
            gap: 10px;
        }
        .army-row {
            display: flex;
            gap: 10px;
            min-height: 100px;
            border: 1px dashed gray;
        }
        .unit {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            margin: 5px;
            border-radius: 5px;
            font-weight: bold;
        }
        .unit.selected-casualty {
            opacity: 0.5;
            text-decoration: line-through;
        }
        .red-army .unit {
            background-color: rgba(255, 0, 0, 0.3);
            border: 1px solid red;
        }
        .blue-army .unit {
            background-color: rgba(0, 0, 255, 0.3);
            border: 1px solid blue;
        }
        #battleLog {
            flex-grow: 1;
            margin: 10px;
            padding: 10px;
            border: 1px solid #ccc;
            height: calc(100vh - 20px);
            column-width: 300px;  /* Set a fixed column width */
            column-gap: 20px;
            column-fill: auto;    /* Fill columns vertically first */
            overflow: auto;        /* Keep scrolling just in case */
        }
        #battleLog h3 {
            column-span: all;
            text-align: center;
        }
        .battle-controls, .combat-controls {
            margin: 10px;
            padding: 10px;
        }
        .hit-highlight {
            background-color: rgba(255, 0, 0, 0.2);
        }
    </style>
</head>
<body>
    <div class="battle-container">
        <div class="army-setup-wrapper">
            <div class="army-setup-row">
                <div id="redArmySetup" class="army-setup red-army">
                    <h2>Attacking Army</h2>
                    <div id="redArmyGrid" class="army-grid">
                        <div class="army-row" row="0"></div>
                        <div class="army-row" row="1"></div>
                        <div class="army-row" row="2"></div>
                    </div>
                    <div id="redUnitTypes" class="unit-types">
                        <button onclick="addUnit('red', 'Samurai')">Samurai</button>
                        <button onclick="addUnit('red', 'Archers')">Archers</button>
                        <button onclick="addUnit('red', 'Gunners')">Gunners</button>
                        <button onclick="addUnit('red', 'Ashigaru')">Ashigaru</button>
                        <button onclick="resetArmy('red')">Reset Army</button>
                    </div>
                </div>

                <div id="blueArmySetup" class="army-setup blue-army">
                    <h2>Defending Army</h2>
                    <div id="blueArmyGrid" class="army-grid">
                        <div class="army-row" row="0"></div>
                        <div class="army-row" row="1"></div>
                        <div class="army-row" row="2"></div>
                    </div>
                    <div id="blueUnitTypes" class="unit-types">
                        <button onclick="addUnit('blue', 'Samurai')">Samurai</button>
                        <button onclick="addUnit('blue', 'Archers')">Archers</button>
                        <button onclick="addUnit('blue', 'Gunners')">Gunners</button>
                        <button onclick="addUnit('blue', 'Ashigaru')">Ashigaru</button>
                        <button onclick="resetArmy('blue')">Reset Army</button>
                    </div>
                </div>
            </div>

            <div class="controls-row">
                <div class="battle-controls">
                    <button onclick="startBattle()">Start Battle</button>
                </div>

                <div class="combat-controls">
                    <div id="casualtyRemoval">
                        <h3 id="casualtyInstructions"></h3>
                        <button id="removeCasualtiesBtn" onclick="removeCasualties()" style="display:none;">Remove Casualties</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="battleLog">
            <h3>Battle Log</h3>
        </div>
    </div>

    <script>
        const UNIT_HIT_RULES = {
            'Daimyo': { hits: 6, dice: 12 },     // hits on 1-6 out of 12
            'Archers': { hits: 6, dice: 12 },    // hits on 1-6 out of 12
            'Samurai': { hits: 5, dice: 12 },    // hits on 1-5 out of 12
            'Gunners': { hits: 4, dice: 12 },    // hits on 1-4 out of 12
            'Ashigaru': { hits: 4, dice: 12 }    // hits on 1-4 out of 12
        };

        let currentBattleState = null;
        let currentPhase = null;
        let currentArmyRemoving = null;
        let combatRound = 0;

        // Initialize armies with Daimyo
        function initializeArmy(armyColor) {
            const grid = document.getElementById(`${armyColor}ArmyGrid`);
            const firstRow = grid.querySelector('.army-row[row="0"]');
            
            // Create Daimyo unit
            const daimyo = document.createElement('div');
            daimyo.className = 'unit';
            daimyo.textContent = 'D';
            daimyo.dataset.type = 'Daimyo';
            daimyo.onclick = () => removeUnit(daimyo);
            firstRow.appendChild(daimyo);
        }

        // Call initialization for both armies
        initializeArmy('red');
        initializeArmy('blue');

        function findAvailableRow(armyColor, unitType) {
            const grid = document.getElementById(`${armyColor}ArmyGrid`);
            const rows = grid.querySelectorAll('.army-row');
            
            // First row: Daimyo (pre-populated), Archers, and Samurai
            if (['Archers', 'Samurai'].includes(unitType)) {
                const firstRow = rows[0];
                if (firstRow.children.length < 5) {
                    return firstRow;
                }
            }
        
            // Rows 2 and 3: Gunners first, then Ashigaru
            if (['Gunners', 'Ashigaru'].includes(unitType)) {
                const secondRow = rows[1];
                const thirdRow = rows[2];
                
                // Prioritize Gunners in the second row first
                if (unitType === 'Gunners' && secondRow.children.length < 5) {
                    return secondRow;
                }
                
                // If no more space for Gunners in second row, try third row
                if (unitType === 'Gunners' && thirdRow.children.length < 5) {
                    return thirdRow;
                }
                
                // For Ashigaru, first try second row
                if (unitType === 'Ashigaru') {
                    // Check if there's space in second row
                    if (secondRow.children.length < 5) {
                        return secondRow;
                    }
                    
                    // If second row is full, try third row
                    if (thirdRow.children.length < 5) {
                        return thirdRow;
                    }
                }
            }
        
            return null;
        }

        function sortRowUnits(row) {
            const priority = {
                'Daimyo': 1,  // Always first in first row
                'Archers': 2,
                'Samurai': 3,
                'Gunners': 1, // First in subsequent rows
                'Ashigaru': 2
            };
        
            const units = Array.from(row.children);
            
            // Sort units based on priority
            const sortedUnits = units.sort((a, b) => {
                const priorityA = priority[a.dataset.type] || 99;
                const priorityB = priority[b.dataset.type] || 99;
                return priorityA - priorityB;
            });
        
            // Clear and re-add sorted units
            row.innerHTML = '';
            sortedUnits.forEach(unit => row.appendChild(unit));
        }

        function addUnit(armyColor, unitType) {
            const totalUnits = document.querySelectorAll(`.${armyColor}-army .unit`).length;
            if (totalUnits >= 15) {
                alert('Army is at maximum capacity (15 units)');
                return;
            }
        
            const row = findAvailableRow(armyColor, unitType);
            if (row) {
                const unit = document.createElement('div');
                unit.className = 'unit';
                
                // Set unit text based on type
                switch(unitType) {
                    case 'Daimyo': unit.textContent = 'D'; break;
                    case 'Archers': unit.textContent = 'A'; break;
                    case 'Samurai': unit.textContent = 'S'; break;
                    case 'Gunners': unit.textContent = 'g'; break;
                    case 'Ashigaru': unit.textContent = 'a'; break;
                }
                
                unit.dataset.type = unitType;
                unit.onclick = () => removeUnit(unit);
                row.appendChild(unit);
        
                // Sort units in the row
                sortRowUnits(row);
            } else {
                alert('No space available for this unit type in the army');
            }
        }

        function removeUnit(unitElement) {
            // If currently selecting casualties, handle selection
            if (currentArmyRemoving) {
                // Check if the unit belongs to the correct army
                const unitArmy = unitElement.closest('.army-setup').id.startsWith('red') ? 'red' : 'blue';
                if (unitArmy === currentArmyRemoving) {
                    // Get count of non-Daimyo units available
                    const armyGrid = document.getElementById(`${unitArmy}ArmyGrid`);
                    const nonDaimyoUnits = Array.from(armyGrid.querySelectorAll('.unit')).filter(unit => 
                        unit.dataset.type !== 'Daimyo' && !unit.classList.contains('selected-casualty')
                    ).length;
        
                    // Only allow Daimyo selection if no other units are available
                    if (unitElement.dataset.type === 'Daimyo' && nonDaimyoUnits > 0) {
                        return; // Prevent Daimyo selection if other units exist
                    }
        
                    // Toggle the selected-casualty class
                    unitElement.classList.toggle('selected-casualty');
                }
            } else {
                // During army setup, prevent Daimyo removal
                if (unitElement.dataset.type === 'Daimyo') {
                    return; // Prevent Daimyo removal
                }
                // Normal unit removal during army setup
                unitElement.remove();
            }
        }

        function resetArmy(armyColor) {
            const grid = document.getElementById(`${armyColor}ArmyGrid`);
            const rows = grid.querySelectorAll('.army-row');
            rows.forEach(row => {
                row.innerHTML = '';
            });
            initializeArmy(armyColor);
        }

        function rollDice(maxHits, totalDice) {
            let hits = 0;
            for (let i = 0; i < totalDice; i++) {
                if (Math.floor(Math.random() * 12) + 1 <= maxHits) {
                    hits++;
                }
            }
            return hits;
        }
   
        function startBattle() {
            const redArmy = document.querySelectorAll('#redArmyGrid .unit');
            const blueArmy = document.querySelectorAll('#blueArmyGrid .unit');
            
            if (redArmy.length === 0 || blueArmy.length === 0) {
                alert('Both armies must have units to start battle!');
                return;
            }
        
            // Disable start battle button but keep the container
            const startButton = document.querySelector('.battle-controls button');
            startButton.style.display = 'none';  // Changed from disabled = true
            
            // Hide all unit control buttons
            document.querySelectorAll('#redUnitTypes button, #blueUnitTypes button').forEach(button => {
                button.style.display = 'none';
            });
            
            // Increment combat round
            combatRound++;
            
            const log = document.getElementById('battleLog');
            log.innerHTML += `<b>Combat Round ${combatRound}</b><br>`;
            
            // Start with Missile Phase
            currentPhase = 'Missile';
            currentBattleState = simulateMissilePhase(redArmy, blueArmy);
            
            // Always prepare blue army casualties first
            if (currentBattleState.blueCasualties > 0) {
                prepareCasualtyRemoval('blue', currentBattleState.blueCasualties);
            } else {
                // If no blue casualties, immediately proceed to red casualties
                prepareCasualtyRemoval('red', currentBattleState.redCasualties);
            }
        }

        function processPhaseCasualties(battleState) {
            // If both armies have casualties
            if (battleState.blueCasualties > 0 && battleState.redCasualties > 0) {
                // Start with blue army casualties
                prepareCasualtyRemoval('blue', battleState.blueCasualties);
            } 
            // If only blue army has casualties
            else if (battleState.blueCasualties > 0) {
                prepareCasualtyRemoval('blue', battleState.blueCasualties);
            } 
            // If only red army has casualties
            else if (battleState.redCasualties > 0) {
                prepareCasualtyRemoval('red', battleState.redCasualties);
            } 
            // If no casualties, proceed to next phase
            else {
                proceedToNextPhase();
            }
        }

        function proceedToNextPhase() {
            // Switch phases
            if (currentPhase === 'Missile') {
                currentPhase = 'Melee';
                currentBattleState = simulateMeleePhase(
                    document.querySelectorAll('#redArmyGrid .unit'),
                    document.querySelectorAll('#blueArmyGrid .unit')
                );
                processPhaseCasualties(currentBattleState);
            } else {
                // End of combat round
                endCombatRound();
            }
        }
        
        function proceedToRedCasualties() {
            // If there are red army casualties from missile phase
            if (currentBattleState.redCasualties > 0) {
                prepareCasualtyRemoval('red', currentBattleState.redCasualties);
            } else {
                // If no red casualties, proceed to melee phase
                proceedToMeleePhase();
            }
        }
        
        function proceedToRedMeleeCasualties() {
            // If there are red army casualties from melee phase
            if (currentBattleState.redCasualties > 0) {
                prepareCasualtyRemoval('red', currentBattleState.redCasualties);
            } else {
                // If no casualties for either army, end the combat round
                endCombatRound();
            }
        }
        
        function proceedToMeleePhase() {
            // Start Melee Phase
            currentPhase = 'Melee';
            currentBattleState = simulateMeleePhase(
                document.querySelectorAll('#redArmyGrid .unit'),
                document.querySelectorAll('#blueArmyGrid .unit')
            );
            
            // Always prepare blue army casualties first
            if (currentBattleState.blueCasualties > 0) {
                prepareCasualtyRemoval('blue', currentBattleState.blueCasualties);
            } else {
                // If no blue casualties, immediately proceed to red casualties
                prepareCasualtyRemoval('red', currentBattleState.redCasualties);
            }
        }
      
        function endCombatRound() {
            const confirmContinue = confirm('Do you want to continue the battle?');
            if (confirmContinue) {
                startBattle(); // Starts a new round
            } else {
                const log = document.getElementById('battleLog');
                log.innerHTML += '<br>Battle has been concluded.<br>';
                log.innerHTML += '<br><i>(Reload the page to start a new battle)</i><br>';
                
                // Add export log button only at the end of the battle
                if (!document.getElementById('exportLogButton')) {
                    const exportButton = document.createElement('button');
                    exportButton.id = 'exportLogButton';
                    exportButton.textContent = 'Export Battle Log';
                    exportButton.onclick = exportBattleLog;
                    document.querySelector('.battle-controls').appendChild(exportButton);
                }
                
                currentBattleState = null;
                currentPhase = null;
            }
        }
        
        function highlightLog(logText) {
            // Create a temporary div to handle the highlighting
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = logText;
            
            // Find and wrap "hit" with a span for highlighting
            const textNodes = [];
            
            // Recursive function to find text nodes
            function getTextNodes(node) {
                if (node.nodeType === Node.TEXT_NODE) {
                    textNodes.push(node);
                } else {
                    for (let child of node.childNodes) {
                        getTextNodes(child);
                    }
                }
            }
            
            getTextNodes(tempDiv);
            
            // Replace "hit" in text nodes
            textNodes.forEach(textNode => {
                const text = textNode.textContent;
                if (text.includes('hit')) {
                    const replacedText = text.replace(/hit/g, '<span class="hit-highlight">hit</span>');
                    const tempSpan = document.createElement('span');
                    tempSpan.innerHTML = replacedText;
                    textNode.parentNode.replaceChild(tempSpan, textNode);
                }
            });
            
            return tempDiv.innerHTML;
        }
        
        function simulateMissilePhase(redArmy, blueArmy) {
            const log = document.getElementById('battleLog');
            log.innerHTML += '<br><u>Missile Phase</u>:<br>';
        
            const redMissileUnits = {
                Archers: Array.from(redArmy).filter(u => u.dataset.type === 'Archers'),
                Gunners: Array.from(redArmy).filter(u => u.dataset.type === 'Gunners')
            };
        
            const blueMissileUnits = {
                Archers: Array.from(blueArmy).filter(u => u.dataset.type === 'Archers'),
                Gunners: Array.from(blueArmy).filter(u => u.dataset.type === 'Gunners')
            };
        
            // Function to process unit rolls and create log
            const processUnitRolls = (army, units) => {
                let missileLog = '';
                let hits = 0;
        
                ['Archers', 'Gunners'].forEach(type => {
                    if (units[type].length > 0) {
                        const typeRolls = units[type].map(unit => {
                            const rules = UNIT_HIT_RULES[type];
                            const roll = Math.floor(Math.random() * 12) + 1;
                            const hit = roll <= rules.hits;
                            return hit ? `hit (${roll})` : `miss (${roll})`;
                        });
                        
                        missileLog += `${army} ${type}: ${typeRolls.join(', ')}<br>`;
                        const typeHits = typeRolls.filter(roll => roll.startsWith('hit')).length;
                        hits += typeHits;
                    }
                });
        
                missileLog += `Total ${army} Missile Hits: ${hits}<br>`;
                return { log: missileLog, hits };
            };
        
            // Process missile phase for both armies
            const redResults = processUnitRolls('Red', redMissileUnits);
            const blueResults = processUnitRolls('Blue', blueMissileUnits);
        
            // Update battle log with highlighting
            document.getElementById('battleLog').innerHTML += 
                highlightLog(redResults.log + '<br>' + blueResults.log);
        
            return {
                redArmy,
                blueArmy,
                blueCasualties: redResults.hits,
                redCasualties: blueResults.hits
            };
        }

        function prepareCasualtyRemoval(armyColor, casualties) {
            // Check if battle has already ended
            if (!currentBattleState) {
                return;
            }
        
            const instructions = document.getElementById('casualtyInstructions');
            const removeButton = document.getElementById('removeCasualtiesBtn');
            const log = document.getElementById('battleLog');
            
            // Reset any previous selections
            const previousSelected = document.querySelectorAll('.selected-casualty');
            previousSelected.forEach(el => el.classList.remove('selected-casualty'));
        
            // Get remaining units for both armies
            const redArmyGrid = document.getElementById('redArmyGrid');
            const blueArmyGrid = document.getElementById('blueArmyGrid');
            const redUnits = redArmyGrid.querySelectorAll('.unit');
            const blueUnits = blueArmyGrid.querySelectorAll('.unit');
        
            // Check if current casualties would destroy the current army
            const currentArmyGrid = document.getElementById(`${armyColor}ArmyGrid`);
            const remainingUnits = currentArmyGrid.querySelectorAll('.unit');
            const nonDaimyoUnits = Array.from(remainingUnits).filter(unit => unit.dataset.type !== 'Daimyo').length;
        
            // If casualties would destroy the current army...
            if (casualties >= remainingUnits.length) {
                // Check if both armies would be destroyed in this phase
                const otherArmy = armyColor === 'blue' ? 'red' : 'blue';
                const otherArmyUnits = document.getElementById(`${otherArmy}ArmyGrid`).querySelectorAll('.unit');
                const otherArmyCasualties = currentBattleState[`${otherArmy}Casualties`];
        
                if (otherArmyCasualties >= otherArmyUnits.length) {
                    // Both armies are destroyed
                    log.innerHTML += '<br>The armies have annihilated each other!!<br>';
                    redArmyGrid.innerHTML = '';
                    blueArmyGrid.innerHTML = '';
                } else {
                    // Only current army is destroyed
                    log.innerHTML += `<br>${armyColor.toUpperCase()} Army is completely destroyed!<br>`;
                    currentArmyGrid.innerHTML = '';
                    
                    // Determine the winner
                    const victorArmy = armyColor === 'blue' ? 'Red' : 'Blue';
                    log.innerHTML += `${victorArmy} Army is victorious!<br>`;
                }
        
                log.innerHTML += '<br><i>(Reload the page to start a new battle)</i><br>';
                
                // Make sure battle controls container exists and is visible
                let battleControls = document.querySelector('.battle-controls');
                if (!battleControls) {
                    battleControls = document.createElement('div');
                    battleControls.className = 'battle-controls';
                    document.querySelector('.controls-row').appendChild(battleControls);
                }
                
                // Add export log button if it doesn't exist
                if (!document.getElementById('exportLogButton')) {
                    const exportButton = document.createElement('button');
                    exportButton.id = 'exportLogButton';
                    exportButton.textContent = 'Export Battle Log';
                    exportButton.onclick = exportBattleLog;
                    battleControls.appendChild(exportButton);
                }
                
                currentBattleState = null;
                currentPhase = null;
                return;
            }

            // If casualties equals number of non-Daimyo units, automatically select all non-Daimyo units
            if (casualties === nonDaimyoUnits) {
                const nonDaimyoElements = Array.from(remainingUnits).filter(unit => unit.dataset.type !== 'Daimyo');
                nonDaimyoElements.forEach(unit => unit.classList.add('selected-casualty'));
            }
        
            // Check if casualties are valid
            if (casualties === 0) {
                // Proceed to next phase based on current phase
                if (currentPhase === 'Missile') {
                    if (armyColor === 'blue') {
                        proceedToRedCasualties();
                    } else {
                        proceedToMeleePhase();
                    }
                } else if (currentPhase === 'Melee') {
                    if (armyColor === 'blue') {
                        proceedToRedMeleeCasualties();
                    } else {
                        endCombatRound();
                    }
                }
                return;
            }
        
            // Reset any previous selections and set up instructions
            const previousSelected = document.querySelectorAll('.selected-casualty');
            previousSelected.forEach(el => el.classList.remove('selected-casualty'));
        
            currentArmyRemoving = armyColor;
        
            const instructions = document.getElementById('casualtyInstructions');
            let instructionText = `<div style="font-size: 1.2em; margin-bottom: 8px;"><b>${currentPhase} Phase Casualties</b></div>`;
            instructionText += `${armyColor.toUpperCase()} Army: Select ${casualties} casualties to remove`;
            if (nonDaimyoUnits > 0) {
                instructionText += " (Daimyo must be the last unit remaining)";
            }
            instructions.innerHTML = instructionText;  // Changed from textContent to innerHTML to handle the styling
            removeButton.style.display = 'block';
        }

        function removeCasualties() {
            const selectedCasualties = document.querySelectorAll('.selected-casualty');
            const expectedCasualties = currentBattleState[`${currentArmyRemoving}Casualties`];
        
            // Validate correct number of casualties selected
            if (selectedCasualties.length !== expectedCasualties) {
                alert(`Please select exactly ${expectedCasualties} casualties`);
                return;
            }
        
            // Remove selected casualties
            selectedCasualties.forEach(casualty => casualty.remove());
        
            // Hide remove button
            document.getElementById('removeCasualtiesBtn').style.display = 'none';
        
            // Determine next steps based on current phase and army removing
            if (currentPhase === 'Missile') {
                if (currentArmyRemoving === 'blue') {
                    // After blue casualties, always process red casualties
                    prepareCasualtyRemoval('red', currentBattleState.redCasualties);
                } else if (currentArmyRemoving === 'red') {
                    // After red casualties in missile phase, move to melee phase
                    proceedToMeleePhase();
                }
            } else if (currentPhase === 'Melee') {
                if (currentArmyRemoving === 'blue') {
                    // After blue casualties, process red casualties
                    prepareCasualtyRemoval('red', currentBattleState.redCasualties);
                } else if (currentArmyRemoving === 'red') {
                    // After red casualties in melee phase, end the round
                    endCombatRound();
                }
            }
        }

        function handleNextPhase() {
            // If just finished missile phase, start melee phase
            if (currentPhase === 'Missile') {
                currentPhase = 'Melee';
                currentBattleState = simulateMeleePhase(
                    document.querySelectorAll('#redArmyGrid .unit'),
                    document.querySelectorAll('#blueArmyGrid .unit')
                );
                
                // Prepare red army casualties
                if (currentBattleState.redCasualties > 0) {
                    prepareCasualtyRemoval('red', currentBattleState.redCasualties);
                } else {
                    // If no red casualties, confirm to continue
                    const confirmContinue = confirm('Do you want to continue the battle?');
                    if (confirmContinue) {
                        startBattle(); // Starts a new round
                    } else {
                        document.getElementById('battleLog').innerHTML += 
                            '<br>Battle has been concluded.';
                        currentBattleState = null;
                        currentPhase = null;
                    }
                }
            } 
            // If just finished red casualties, confirm to continue
            else {
                const confirmContinue = confirm('Do you want to continue the battle?');
                if (confirmContinue) {
                    startBattle(); // Starts a new round
                } else {
                    document.getElementById('battleLog').innerHTML += 
                        '<br>Battle has been concluded.';
                    currentBattleState = null;
                    currentPhase = null;
                }
            }
        }
        
        function simulateMeleePhase(redArmy, blueArmy) {
            const log = document.getElementById('battleLog');
            log.innerHTML += '<br><u>Melee Phase</u>:<br>';
        
            const redMeleeUnits = {
                Daimyo: Array.from(redArmy).filter(u => u.dataset.type === 'Daimyo'),
                Samurai: Array.from(redArmy).filter(u => u.dataset.type === 'Samurai'),
                Ashigaru: Array.from(redArmy).filter(u => u.dataset.type === 'Ashigaru')
            };
        
            const blueMeleeUnits = {
                Daimyo: Array.from(blueArmy).filter(u => u.dataset.type === 'Daimyo'),
                Samurai: Array.from(blueArmy).filter(u => u.dataset.type === 'Samurai'),
                Ashigaru: Array.from(blueArmy).filter(u => u.dataset.type === 'Ashigaru')
            };
        
            // Function to process unit rolls and create log
            const processUnitRolls = (army, units) => {
                let meleeLog = '';
                let hits = 0;
        
                ['Daimyo', 'Samurai', 'Ashigaru'].forEach(type => {
                    if (units[type].length > 0) {
                        const typeRolls = units[type].map(unit => {
                            const rules = UNIT_HIT_RULES[type];
                            const roll = Math.floor(Math.random() * 12) + 1;
                            const hit = roll <= rules.hits;
                            return hit ? `hit (${roll})` : `miss (${roll})`;
                        });
                        
                        meleeLog += `${army} ${type}: ${typeRolls.join(', ')}<br>`;
                        const typeHits = typeRolls.filter(roll => roll.startsWith('hit')).length;
                        hits += typeHits;
                    }
                });
        
                meleeLog += `Total ${army} Melee Hits: ${hits}<br>`;
                return { log: meleeLog, hits };
            };
        
            // Process melee phase for both armies
            const redResults = processUnitRolls('Red', redMeleeUnits);
            const blueResults = processUnitRolls('Blue', blueMeleeUnits);
                
            // Update battle log with highlighting
            document.getElementById('battleLog').innerHTML += 
                highlightLog(redResults.log + '<br>' + blueResults.log);
         
            return {
                redArmy,
                blueArmy,
                blueCasualties: redResults.hits,
                redCasualties: blueResults.hits
            };
        }

        function exportBattleLog() {
            const log = document.getElementById('battleLog').innerText;
            const blob = new Blob([log], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'battle_log.txt';
            a.click();
            window.URL.revokeObjectURL(url);
        }
        
    </script>
</body>
</html>
